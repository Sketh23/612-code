\hypertarget{classAnalogChannel}{
\section{AnalogChannel Class Reference}
\label{classAnalogChannel}\index{AnalogChannel@{AnalogChannel}}
}


{\ttfamily \#include $<$AnalogChannel.h$>$}

Inheritance diagram for AnalogChannel:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=3.000000cm]{classAnalogChannel}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classAnalogChannel_a8928766b0b7a5f5010acb5deb354f8f3}{AnalogChannel} (UINT8 moduleNumber, UINT32 channel)
\item 
\hyperlink{classAnalogChannel_a9596b1752bb22dcb1295c2158042ec76}{AnalogChannel} (UINT32 channel)
\item 
virtual \hyperlink{classAnalogChannel_aab41f5e25b1a9a8fa1b935783dcc89a1}{$\sim$AnalogChannel} ()
\item 
\hyperlink{classAnalogModule}{AnalogModule} $\ast$ \hyperlink{classAnalogChannel_aa8c8f0328ba7a4074d0f8c8fe8738327}{GetModule} ()
\item 
INT16 \hyperlink{classAnalogChannel_ab9d814ee9f311c6beb2b379e60aee79a}{GetValue} ()
\item 
INT32 \hyperlink{classAnalogChannel_a35dda9856d45c0fe807337ab3678b212}{GetAverageValue} ()
\item 
float \hyperlink{classAnalogChannel_a8032c882a142a01c43ea16c817fc2290}{GetVoltage} ()
\item 
float \hyperlink{classAnalogChannel_aba0ed352ce011170556c039c939f8731}{GetAverageVoltage} ()
\item 
UINT8 \hyperlink{classAnalogChannel_a5731d3c308e74c9011b81238aedcbd0e}{GetModuleNumber} ()
\item 
UINT32 \hyperlink{classAnalogChannel_a5d191a8fb04536a9c20355e6e5b97262}{GetChannel} ()
\item 
void \hyperlink{classAnalogChannel_a64da26075ace6b51c635ed4b0646742b}{SetAverageBits} (UINT32 bits)
\item 
UINT32 \hyperlink{classAnalogChannel_ab73e958a37fece26e7dd9fd3c358684e}{GetAverageBits} ()
\item 
void \hyperlink{classAnalogChannel_a69c5b8dd70a0a5792f2522b2b4758fc3}{SetOversampleBits} (UINT32 bits)
\item 
UINT32 \hyperlink{classAnalogChannel_ae7ddc6516b2ecba8d1e9b9abab9a5939}{GetOversampleBits} ()
\item 
UINT32 \hyperlink{classAnalogChannel_a6a491e56a5d92d4400bf7bde40eda2cc}{GetLSBWeight} ()
\item 
INT32 \hyperlink{classAnalogChannel_a0e2d698faf502d341f16cadad26e39fd}{GetOffset} ()
\item 
bool \hyperlink{classAnalogChannel_a6915bcc0cb08e270812f31fdf7aa6caa}{IsAccumulatorChannel} ()
\item 
void \hyperlink{classAnalogChannel_a8f3c0b9bd0ca7ab9449b89e5c2abd53f}{InitAccumulator} ()
\item 
void \hyperlink{classAnalogChannel_aae43ed632a10270fd163d44eea2d8f8f}{SetAccumulatorInitialValue} (INT64 value)
\item 
void \hyperlink{classAnalogChannel_aecf5da778576f4904e51ece5d327ea17}{ResetAccumulator} ()
\item 
void \hyperlink{classAnalogChannel_a1e28d604275cfda65b8a5e1b5bd79134}{SetAccumulatorCenter} (INT32 center)
\item 
void \hyperlink{classAnalogChannel_ac404eb71545eb04daf9d09c465e0997a}{SetAccumulatorDeadband} (INT32 deadband)
\item 
INT64 \hyperlink{classAnalogChannel_a8ad12eb79e2ae1c981654ec4907b0f03}{GetAccumulatorValue} ()
\item 
UINT32 \hyperlink{classAnalogChannel_a234fa038c75f10ddfc20147740d61dda}{GetAccumulatorCount} ()
\item 
void \hyperlink{classAnalogChannel_ae133b8fe46584ea20b35ea3a0294c2bb}{GetAccumulatorOutput} (INT64 $\ast$value, UINT32 $\ast$count)
\item 
double \hyperlink{classAnalogChannel_ac6317cfcc26ddff2289f8efc242d99d3}{PIDGet} ()
\end{DoxyCompactItemize}
\subsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
\hypertarget{classAnalogChannel_ac1f9aaaf38df6f26768539ddb493b59e}{
static const UINT8 {\bfseries kAccumulatorModuleNumber} = 1}
\label{classAnalogChannel_ac1f9aaaf38df6f26768539ddb493b59e}

\item 
\hypertarget{classAnalogChannel_aa1ecbaa46e972b4d404ce260d58c5c34}{
static const UINT32 {\bfseries kAccumulatorNumChannels} = 2}
\label{classAnalogChannel_aa1ecbaa46e972b4d404ce260d58c5c34}

\item 
\hypertarget{classAnalogChannel_ae83f8b390f6f72a1eb743352e688b7f8}{
static const UINT32 {\bfseries kAccumulatorChannels} \mbox{[}kAccumulatorNumChannels\mbox{]} = \{1, 2\}}
\label{classAnalogChannel_ae83f8b390f6f72a1eb743352e688b7f8}

\end{DoxyCompactItemize}


\subsection{Detailed Description}
Analog channel class.

Each analog channel is read from hardware as a 12-\/bit number representing -\/10V to 10V.

Connected to each analog channel is an averaging and oversampling engine. This engine accumulates the specified ( by \hyperlink{classAnalogChannel_a64da26075ace6b51c635ed4b0646742b}{SetAverageBits()} and \hyperlink{classAnalogChannel_a69c5b8dd70a0a5792f2522b2b4758fc3}{SetOversampleBits()} ) number of samples before returning a new value. This is not a sliding window average. The only difference between the oversampled samples and the averaged samples is that the oversampled samples are simply accumulated effectively increasing the resolution, while the averaged samples are divided by the number of samples to retain the resolution, but get more stable values. 

\subsection{Constructor \& Destructor Documentation}
\hypertarget{classAnalogChannel_a8928766b0b7a5f5010acb5deb354f8f3}{
\index{AnalogChannel@{AnalogChannel}!AnalogChannel@{AnalogChannel}}
\index{AnalogChannel@{AnalogChannel}!AnalogChannel@{AnalogChannel}}
\subsubsection[{AnalogChannel}]{\setlength{\rightskip}{0pt plus 5cm}AnalogChannel::AnalogChannel (
\begin{DoxyParamCaption}
\item[{UINT8}]{moduleNumber, }
\item[{UINT32}]{channel}
\end{DoxyParamCaption}
)}}
\label{classAnalogChannel_a8928766b0b7a5f5010acb5deb354f8f3}
Construct an analog channel on a specified module.


\begin{DoxyParams}{Parameters}
{\em moduleNumber} & The analog module (1 or 2). \\
\hline
{\em channel} & The channel number to represent. \\
\hline
\end{DoxyParams}
\hypertarget{classAnalogChannel_a9596b1752bb22dcb1295c2158042ec76}{
\index{AnalogChannel@{AnalogChannel}!AnalogChannel@{AnalogChannel}}
\index{AnalogChannel@{AnalogChannel}!AnalogChannel@{AnalogChannel}}
\subsubsection[{AnalogChannel}]{\setlength{\rightskip}{0pt plus 5cm}AnalogChannel::AnalogChannel (
\begin{DoxyParamCaption}
\item[{UINT32}]{channel}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}explicit\mbox{]}}}}
\label{classAnalogChannel_a9596b1752bb22dcb1295c2158042ec76}
Construct an analog channel on the default module.


\begin{DoxyParams}{Parameters}
{\em channel} & The channel number to represent. \\
\hline
\end{DoxyParams}
\hypertarget{classAnalogChannel_aab41f5e25b1a9a8fa1b935783dcc89a1}{
\index{AnalogChannel@{AnalogChannel}!$\sim$AnalogChannel@{$\sim$AnalogChannel}}
\index{$\sim$AnalogChannel@{$\sim$AnalogChannel}!AnalogChannel@{AnalogChannel}}
\subsubsection[{$\sim$AnalogChannel}]{\setlength{\rightskip}{0pt plus 5cm}AnalogChannel::$\sim$AnalogChannel (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classAnalogChannel_aab41f5e25b1a9a8fa1b935783dcc89a1}
Channel destructor. 

\subsection{Member Function Documentation}
\hypertarget{classAnalogChannel_a234fa038c75f10ddfc20147740d61dda}{
\index{AnalogChannel@{AnalogChannel}!GetAccumulatorCount@{GetAccumulatorCount}}
\index{GetAccumulatorCount@{GetAccumulatorCount}!AnalogChannel@{AnalogChannel}}
\subsubsection[{GetAccumulatorCount}]{\setlength{\rightskip}{0pt plus 5cm}UINT32 AnalogChannel::GetAccumulatorCount (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classAnalogChannel_a234fa038c75f10ddfc20147740d61dda}
Read the number of accumulated values.

Read the count of the accumulated values since the accumulator was last Reset().

\begin{DoxyReturn}{Returns}
The number of times samples from the channel were accumulated. 
\end{DoxyReturn}
\hypertarget{classAnalogChannel_ae133b8fe46584ea20b35ea3a0294c2bb}{
\index{AnalogChannel@{AnalogChannel}!GetAccumulatorOutput@{GetAccumulatorOutput}}
\index{GetAccumulatorOutput@{GetAccumulatorOutput}!AnalogChannel@{AnalogChannel}}
\subsubsection[{GetAccumulatorOutput}]{\setlength{\rightskip}{0pt plus 5cm}void AnalogChannel::GetAccumulatorOutput (
\begin{DoxyParamCaption}
\item[{INT64 $\ast$}]{value, }
\item[{UINT32 $\ast$}]{count}
\end{DoxyParamCaption}
)}}
\label{classAnalogChannel_ae133b8fe46584ea20b35ea3a0294c2bb}
Read the accumulated value and the number of accumulated values atomically.

This function reads the value and count from the FPGA atomically. This can be used for averaging.


\begin{DoxyParams}{Parameters}
{\em value} & Pointer to the 64-\/bit accumulated output. \\
\hline
{\em count} & Pointer to the number of accumulation cycles. \\
\hline
\end{DoxyParams}
\hypertarget{classAnalogChannel_a8ad12eb79e2ae1c981654ec4907b0f03}{
\index{AnalogChannel@{AnalogChannel}!GetAccumulatorValue@{GetAccumulatorValue}}
\index{GetAccumulatorValue@{GetAccumulatorValue}!AnalogChannel@{AnalogChannel}}
\subsubsection[{GetAccumulatorValue}]{\setlength{\rightskip}{0pt plus 5cm}INT64 AnalogChannel::GetAccumulatorValue (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classAnalogChannel_a8ad12eb79e2ae1c981654ec4907b0f03}
Read the accumulated value.

Read the value that has been accumulating on channel 1. The accumulator is attached after the oversample and average engine.

\begin{DoxyReturn}{Returns}
The 64-\/bit value accumulated since the last Reset(). 
\end{DoxyReturn}
\hypertarget{classAnalogChannel_ab73e958a37fece26e7dd9fd3c358684e}{
\index{AnalogChannel@{AnalogChannel}!GetAverageBits@{GetAverageBits}}
\index{GetAverageBits@{GetAverageBits}!AnalogChannel@{AnalogChannel}}
\subsubsection[{GetAverageBits}]{\setlength{\rightskip}{0pt plus 5cm}UINT32 AnalogChannel::GetAverageBits (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classAnalogChannel_ab73e958a37fece26e7dd9fd3c358684e}
Get the number of averaging bits previously configured. This gets the number of averaging bits from the FPGA. The actual number of averaged samples is 2$\ast$$\ast$bits. The averaging is done automatically in the FPGA.

\begin{DoxyReturn}{Returns}
Number of bits of averaging previously configured. 
\end{DoxyReturn}
\hypertarget{classAnalogChannel_a35dda9856d45c0fe807337ab3678b212}{
\index{AnalogChannel@{AnalogChannel}!GetAverageValue@{GetAverageValue}}
\index{GetAverageValue@{GetAverageValue}!AnalogChannel@{AnalogChannel}}
\subsubsection[{GetAverageValue}]{\setlength{\rightskip}{0pt plus 5cm}INT32 AnalogChannel::GetAverageValue (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classAnalogChannel_a35dda9856d45c0fe807337ab3678b212}
Get a sample from the output of the oversample and average engine for this channel. The sample is 12-\/bit + the value configured in \hyperlink{classAnalogChannel_a69c5b8dd70a0a5792f2522b2b4758fc3}{SetOversampleBits()}. The value configured in \hyperlink{classAnalogChannel_a64da26075ace6b51c635ed4b0646742b}{SetAverageBits()} will cause this value to be averaged 2$\ast$$\ast$bits number of samples. This is not a sliding window. The sample will not change until 2$\ast$$\ast$(OversamplBits + AverageBits) samples have been acquired from the module on this channel. Use \hyperlink{classAnalogChannel_aba0ed352ce011170556c039c939f8731}{GetAverageVoltage()} to get the analog value in calibrated units. \begin{DoxyReturn}{Returns}
A sample from the oversample and average engine for this channel. 
\end{DoxyReturn}
\hypertarget{classAnalogChannel_aba0ed352ce011170556c039c939f8731}{
\index{AnalogChannel@{AnalogChannel}!GetAverageVoltage@{GetAverageVoltage}}
\index{GetAverageVoltage@{GetAverageVoltage}!AnalogChannel@{AnalogChannel}}
\subsubsection[{GetAverageVoltage}]{\setlength{\rightskip}{0pt plus 5cm}float AnalogChannel::GetAverageVoltage (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classAnalogChannel_aba0ed352ce011170556c039c939f8731}
Get a scaled sample from the output of the oversample and average engine for this channel. The value is scaled to units of Volts using the calibrated scaling data from \hyperlink{classAnalogChannel_a6a491e56a5d92d4400bf7bde40eda2cc}{GetLSBWeight()} and \hyperlink{classAnalogChannel_a0e2d698faf502d341f16cadad26e39fd}{GetOffset()}. Using oversampling will cause this value to be higher resolution, but it will update more slowly. Using averaging will cause this value to be more stable, but it will update more slowly. \begin{DoxyReturn}{Returns}
A scaled sample from the output of the oversample and average engine for this channel. 
\end{DoxyReturn}
\hypertarget{classAnalogChannel_a5d191a8fb04536a9c20355e6e5b97262}{
\index{AnalogChannel@{AnalogChannel}!GetChannel@{GetChannel}}
\index{GetChannel@{GetChannel}!AnalogChannel@{AnalogChannel}}
\subsubsection[{GetChannel}]{\setlength{\rightskip}{0pt plus 5cm}UINT32 AnalogChannel::GetChannel (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classAnalogChannel_a5d191a8fb04536a9c20355e6e5b97262}
Get the channel number. \begin{DoxyReturn}{Returns}
The channel number. 
\end{DoxyReturn}
\hypertarget{classAnalogChannel_a6a491e56a5d92d4400bf7bde40eda2cc}{
\index{AnalogChannel@{AnalogChannel}!GetLSBWeight@{GetLSBWeight}}
\index{GetLSBWeight@{GetLSBWeight}!AnalogChannel@{AnalogChannel}}
\subsubsection[{GetLSBWeight}]{\setlength{\rightskip}{0pt plus 5cm}UINT32 AnalogChannel::GetLSBWeight (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classAnalogChannel_a6a491e56a5d92d4400bf7bde40eda2cc}
Get the factory scaling least significant bit weight constant. The least significant bit weight constant for the channel that was calibrated in manufacturing and stored in an eeprom in the module.

Volts = ((LSB\_\-Weight $\ast$ 1e-\/9) $\ast$ raw) -\/ (Offset $\ast$ 1e-\/9)

\begin{DoxyReturn}{Returns}
Least significant bit weight. 
\end{DoxyReturn}
\hypertarget{classAnalogChannel_aa8c8f0328ba7a4074d0f8c8fe8738327}{
\index{AnalogChannel@{AnalogChannel}!GetModule@{GetModule}}
\index{GetModule@{GetModule}!AnalogChannel@{AnalogChannel}}
\subsubsection[{GetModule}]{\setlength{\rightskip}{0pt plus 5cm}{\bf AnalogModule} $\ast$ AnalogChannel::GetModule (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classAnalogChannel_aa8c8f0328ba7a4074d0f8c8fe8738327}
Get the analog module that this channel is on. \begin{DoxyReturn}{Returns}
A pointer to the \hyperlink{classAnalogModule}{AnalogModule} that this channel is on. 
\end{DoxyReturn}
\hypertarget{classAnalogChannel_a5731d3c308e74c9011b81238aedcbd0e}{
\index{AnalogChannel@{AnalogChannel}!GetModuleNumber@{GetModuleNumber}}
\index{GetModuleNumber@{GetModuleNumber}!AnalogChannel@{AnalogChannel}}
\subsubsection[{GetModuleNumber}]{\setlength{\rightskip}{0pt plus 5cm}UINT8 AnalogChannel::GetModuleNumber (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classAnalogChannel_a5731d3c308e74c9011b81238aedcbd0e}
Get the module number. \begin{DoxyReturn}{Returns}
The module number. 
\end{DoxyReturn}
\hypertarget{classAnalogChannel_a0e2d698faf502d341f16cadad26e39fd}{
\index{AnalogChannel@{AnalogChannel}!GetOffset@{GetOffset}}
\index{GetOffset@{GetOffset}!AnalogChannel@{AnalogChannel}}
\subsubsection[{GetOffset}]{\setlength{\rightskip}{0pt plus 5cm}INT32 AnalogChannel::GetOffset (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classAnalogChannel_a0e2d698faf502d341f16cadad26e39fd}
Get the factory scaling offset constant. The offset constant for the channel that was calibrated in manufacturing and stored in an eeprom in the module.

Volts = ((LSB\_\-Weight $\ast$ 1e-\/9) $\ast$ raw) -\/ (Offset $\ast$ 1e-\/9)

\begin{DoxyReturn}{Returns}
Offset constant. 
\end{DoxyReturn}
\hypertarget{classAnalogChannel_ae7ddc6516b2ecba8d1e9b9abab9a5939}{
\index{AnalogChannel@{AnalogChannel}!GetOversampleBits@{GetOversampleBits}}
\index{GetOversampleBits@{GetOversampleBits}!AnalogChannel@{AnalogChannel}}
\subsubsection[{GetOversampleBits}]{\setlength{\rightskip}{0pt plus 5cm}UINT32 AnalogChannel::GetOversampleBits (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classAnalogChannel_ae7ddc6516b2ecba8d1e9b9abab9a5939}
Get the number of oversample bits previously configured. This gets the number of oversample bits from the FPGA. The actual number of oversampled values is 2$\ast$$\ast$bits. The oversampling is done automatically in the FPGA.

\begin{DoxyReturn}{Returns}
Number of bits of oversampling previously configured. 
\end{DoxyReturn}
\hypertarget{classAnalogChannel_ab9d814ee9f311c6beb2b379e60aee79a}{
\index{AnalogChannel@{AnalogChannel}!GetValue@{GetValue}}
\index{GetValue@{GetValue}!AnalogChannel@{AnalogChannel}}
\subsubsection[{GetValue}]{\setlength{\rightskip}{0pt plus 5cm}INT16 AnalogChannel::GetValue (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classAnalogChannel_ab9d814ee9f311c6beb2b379e60aee79a}
Get a sample straight from this channel on the module. The sample is a 12-\/bit value representing the -\/10V to 10V range of the A/D converter in the module. The units are in A/D converter codes. Use \hyperlink{classAnalogChannel_a8032c882a142a01c43ea16c817fc2290}{GetVoltage()} to get the analog value in calibrated units. \begin{DoxyReturn}{Returns}
A sample straight from this channel on the module. 
\end{DoxyReturn}
\hypertarget{classAnalogChannel_a8032c882a142a01c43ea16c817fc2290}{
\index{AnalogChannel@{AnalogChannel}!GetVoltage@{GetVoltage}}
\index{GetVoltage@{GetVoltage}!AnalogChannel@{AnalogChannel}}
\subsubsection[{GetVoltage}]{\setlength{\rightskip}{0pt plus 5cm}float AnalogChannel::GetVoltage (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classAnalogChannel_a8032c882a142a01c43ea16c817fc2290}
Get a scaled sample straight from this channel on the module. The value is scaled to units of Volts using the calibrated scaling data from \hyperlink{classAnalogChannel_a6a491e56a5d92d4400bf7bde40eda2cc}{GetLSBWeight()} and \hyperlink{classAnalogChannel_a0e2d698faf502d341f16cadad26e39fd}{GetOffset()}. \begin{DoxyReturn}{Returns}
A scaled sample straight from this channel on the module. 
\end{DoxyReturn}
\hypertarget{classAnalogChannel_a8f3c0b9bd0ca7ab9449b89e5c2abd53f}{
\index{AnalogChannel@{AnalogChannel}!InitAccumulator@{InitAccumulator}}
\index{InitAccumulator@{InitAccumulator}!AnalogChannel@{AnalogChannel}}
\subsubsection[{InitAccumulator}]{\setlength{\rightskip}{0pt plus 5cm}void AnalogChannel::InitAccumulator (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classAnalogChannel_a8f3c0b9bd0ca7ab9449b89e5c2abd53f}
Initialize the accumulator. \hypertarget{classAnalogChannel_a6915bcc0cb08e270812f31fdf7aa6caa}{
\index{AnalogChannel@{AnalogChannel}!IsAccumulatorChannel@{IsAccumulatorChannel}}
\index{IsAccumulatorChannel@{IsAccumulatorChannel}!AnalogChannel@{AnalogChannel}}
\subsubsection[{IsAccumulatorChannel}]{\setlength{\rightskip}{0pt plus 5cm}bool AnalogChannel::IsAccumulatorChannel (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classAnalogChannel_a6915bcc0cb08e270812f31fdf7aa6caa}
Is the channel attached to an accumulator.

\begin{DoxyReturn}{Returns}
The analog channel is attached to an accumulator. 
\end{DoxyReturn}
\hypertarget{classAnalogChannel_ac6317cfcc26ddff2289f8efc242d99d3}{
\index{AnalogChannel@{AnalogChannel}!PIDGet@{PIDGet}}
\index{PIDGet@{PIDGet}!AnalogChannel@{AnalogChannel}}
\subsubsection[{PIDGet}]{\setlength{\rightskip}{0pt plus 5cm}double AnalogChannel::PIDGet (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classAnalogChannel_ac6317cfcc26ddff2289f8efc242d99d3}
Get the Average voltage for the PID Source base object.

\begin{DoxyReturn}{Returns}
The average voltage. 
\end{DoxyReturn}


Implements \hyperlink{classPIDSource}{PIDSource}.

\hypertarget{classAnalogChannel_aecf5da778576f4904e51ece5d327ea17}{
\index{AnalogChannel@{AnalogChannel}!ResetAccumulator@{ResetAccumulator}}
\index{ResetAccumulator@{ResetAccumulator}!AnalogChannel@{AnalogChannel}}
\subsubsection[{ResetAccumulator}]{\setlength{\rightskip}{0pt plus 5cm}void AnalogChannel::ResetAccumulator (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classAnalogChannel_aecf5da778576f4904e51ece5d327ea17}
Resets the accumulator to the initial value. \hypertarget{classAnalogChannel_a1e28d604275cfda65b8a5e1b5bd79134}{
\index{AnalogChannel@{AnalogChannel}!SetAccumulatorCenter@{SetAccumulatorCenter}}
\index{SetAccumulatorCenter@{SetAccumulatorCenter}!AnalogChannel@{AnalogChannel}}
\subsubsection[{SetAccumulatorCenter}]{\setlength{\rightskip}{0pt plus 5cm}void AnalogChannel::SetAccumulatorCenter (
\begin{DoxyParamCaption}
\item[{INT32}]{center}
\end{DoxyParamCaption}
)}}
\label{classAnalogChannel_a1e28d604275cfda65b8a5e1b5bd79134}
Set the center value of the accumulator.

The center value is subtracted from each A/D value before it is added to the accumulator. This is used for the center value of devices like gyros and accelerometers to make integration work and to take the device offset into account when integrating.

This center value is based on the output of the oversampled and averaged source from channel 1. Because of this, any non-\/zero oversample bits will affect the size of the value for this field. \hypertarget{classAnalogChannel_ac404eb71545eb04daf9d09c465e0997a}{
\index{AnalogChannel@{AnalogChannel}!SetAccumulatorDeadband@{SetAccumulatorDeadband}}
\index{SetAccumulatorDeadband@{SetAccumulatorDeadband}!AnalogChannel@{AnalogChannel}}
\subsubsection[{SetAccumulatorDeadband}]{\setlength{\rightskip}{0pt plus 5cm}void AnalogChannel::SetAccumulatorDeadband (
\begin{DoxyParamCaption}
\item[{INT32}]{deadband}
\end{DoxyParamCaption}
)}}
\label{classAnalogChannel_ac404eb71545eb04daf9d09c465e0997a}
Set the accumulator's deadband. \hypertarget{classAnalogChannel_aae43ed632a10270fd163d44eea2d8f8f}{
\index{AnalogChannel@{AnalogChannel}!SetAccumulatorInitialValue@{SetAccumulatorInitialValue}}
\index{SetAccumulatorInitialValue@{SetAccumulatorInitialValue}!AnalogChannel@{AnalogChannel}}
\subsubsection[{SetAccumulatorInitialValue}]{\setlength{\rightskip}{0pt plus 5cm}void AnalogChannel::SetAccumulatorInitialValue (
\begin{DoxyParamCaption}
\item[{INT64}]{initialValue}
\end{DoxyParamCaption}
)}}
\label{classAnalogChannel_aae43ed632a10270fd163d44eea2d8f8f}
Set an inital value for the accumulator.

This will be added to all values returned to the user. 
\begin{DoxyParams}{Parameters}
{\em initialValue} & The value that the accumulator should start from when reset. \\
\hline
\end{DoxyParams}
\hypertarget{classAnalogChannel_a64da26075ace6b51c635ed4b0646742b}{
\index{AnalogChannel@{AnalogChannel}!SetAverageBits@{SetAverageBits}}
\index{SetAverageBits@{SetAverageBits}!AnalogChannel@{AnalogChannel}}
\subsubsection[{SetAverageBits}]{\setlength{\rightskip}{0pt plus 5cm}void AnalogChannel::SetAverageBits (
\begin{DoxyParamCaption}
\item[{UINT32}]{bits}
\end{DoxyParamCaption}
)}}
\label{classAnalogChannel_a64da26075ace6b51c635ed4b0646742b}
Set the number of averaging bits. This sets the number of averaging bits. The actual number of averaged samples is 2$\ast$$\ast$bits. Use averaging to improve the stability of your measurement at the expense of sampling rate. The averaging is done automatically in the FPGA.


\begin{DoxyParams}{Parameters}
{\em bits} & Number of bits of averaging. \\
\hline
\end{DoxyParams}
\hypertarget{classAnalogChannel_a69c5b8dd70a0a5792f2522b2b4758fc3}{
\index{AnalogChannel@{AnalogChannel}!SetOversampleBits@{SetOversampleBits}}
\index{SetOversampleBits@{SetOversampleBits}!AnalogChannel@{AnalogChannel}}
\subsubsection[{SetOversampleBits}]{\setlength{\rightskip}{0pt plus 5cm}void AnalogChannel::SetOversampleBits (
\begin{DoxyParamCaption}
\item[{UINT32}]{bits}
\end{DoxyParamCaption}
)}}
\label{classAnalogChannel_a69c5b8dd70a0a5792f2522b2b4758fc3}
Set the number of oversample bits. This sets the number of oversample bits. The actual number of oversampled values is 2$\ast$$\ast$bits. Use oversampling to improve the resolution of your measurements at the expense of sampling rate. The oversampling is done automatically in the FPGA.


\begin{DoxyParams}{Parameters}
{\em bits} & Number of bits of oversampling. \\
\hline
\end{DoxyParams}


The documentation for this class was generated from the following files:\begin{DoxyCompactItemize}
\item 
AnalogChannel.h\item 
AnalogChannel.cpp\end{DoxyCompactItemize}
